## 실행 컨텍스트

### 실행 컨텍스트란

```
실행 컨텍스트는 코드가 실행되는 환경을 설명하는 개념.
런타임시 JavaScript 엔진에 의해 생성되고 사용되는 개체 집합을 의미.
```

#### 정리

`scope`, `hoisting`, `this`, `function`, `closure`등의 동작원리를 담고있는 **자바스크립트 핵심원리**이며,

**실행할 코드에 제공할 환경 정보들을 모아놓은 객체**를 뜻한다.

함수가 실행되면 함수 실행에 해당하는 `실행 컨텍스트`가 생성되고, JS 엔진에 있는 `콜 스택`에 순서대로 쌓인다

가장 위에 쌓여있는 컨텍스트와 관련있는 코드를 실행하면서, 전체 코드의 환경과 순서를 보장하게 된다.

실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와

코드 실행 순서 관리를 구현한 내부 매커니즘으로, 실행 컨텍스트는 곧 JS의 핵심 원리이다.

### 실행 컨텍스트는 언제 생성될까?

JS 엔진이 script 처음 마주할때 전역 컨텍스트를 생성하고, 콜 스택에 `push`한다.

엔진이 script를 쭉 읽어 내려가면서 함수 호출을 발견할 때마다, 함수의 실행 컨텍스트를 스택에 push한다

(함수가 **실행** 될 때)

곧, 실행 컨텍스트가 생성되는 시점은 **함수를 실행하는 시점**이다.

---

### 콜스택이란?

```
함수 호출과 관련된 실행 컨텍스트를 관리하는 데이터 구조

함수의 호출과 반환, 변수 저장을 추적하는데 사용되며
프로그램 실행 중 발생하는 함수 호출에 대한 정보를 저장한다
```

#### 콜 스택 작동 방식

1. **함수 호출 시** 호출한 **함수에 대한 정보**(반환 주소, 함수 인수, 지역 변수)등을 스택 프레임이라고 부르는 단위로 콜스택에 **저장(push)**한다

2. **함수가 실행을 완료**하고 **반환**할 때 해당 함수 스택 프레임을 콜 스택에서 **제거(pop)**하고 반환 주소를 사용해 호출자 함수로 돌아간다.

---

### 호이스팅은 왜 일어날까

#### 호이스팅이란

```
코드를 실행하기 전 함수, 변수, 클래스 또는 임포트의 선언문을 해당 범위의 맨 위로 이동시키는 과정

정확히는 끌어 올려지는 것처럼 보이는 현상이다
```

#### 호이스팅이 일어나는 이유

1. 변수 및 함수 선언 끌어올리기

- JS엔진은 코드를 실행 전 변수/함수 선언을 해당 스코프 내에서 최상위로 끌어 올려서 선언된 변수/함수는 선언 위치와 상관없이 일어난다.

2. 초기화와 할당 구분

- 호이스팅은 변수 선언을 끌어올리지만 초기화나 할당은 끌어올리지 않는다. 따라서 변수가 선언됐을 때 초기화되지 않으면 `undefined`로 설정된다.

#### 호이스팅 예시문

```
console.log(x); // undefined
var x = 5;
console.log(x); // 5

함수 선언식
foo(); // "Hello, I'm a function!"
function foo() {
  console.log("Hello, I'm a function!");
}

함수 표현식(호이스팅 되지 않음)
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log("Hello, I'm a function expression!");
};
```

변수 'x'와 함수 'foo'는 선언하기 전에 참조가 된다. 해당 스코프 내에서 최상위로 끌어올려지면서, JS 호이스팅으로 오류 없이 실행된다.

변수 bar는 함수 표현식으로 선언되었고, 이는 호이스팅되지 않는다. 따라서 bar()를 호출하기 전에 bar에 함수가 할당되지 않아 오류가 발생한다

---

### Temporal Dead Zone (TDZ) : 일시적 사각지대

변수가 선언된 이후 초기화되기 전(**값 할당 하기 전**)까지 변수를 참조할 때 발생하며, 이때 ReferenceError가 발생한다.

변수가 선언 위치에서부터 초기화되기 전까지 해당 변수를 사용할 수 없음을 의미한다.

```
console.log(x); // ReferenceError: x is not defined
let x = 5;
```

TDZ는 주로 let 및 const와 같은 블록 스코프 변수에 적용된다.

\*블록스코프 : 변수가 **선언된 블록 내에서만 유효**하고 외부에서는 접근할 수 없음을 의미

---

### 호이스팅 현상과 실행 컨텍스트의 연관성

#### - 호이스팅과 실행 컨텍스트 생성:

코드가 실행되면 JS 엔진은 실행 컨텍스트를 생성한다

실행 컨텍스트는 **함수 또는 전역 코드와 같은 코드 블록에 대한 실행 환경**을 나타낸다

#### - 호이스팅과 변수 및 함수 선언:

실행 컨텍스트가 생성되면 JS 엔진은 해당 **컨텍스트 내에서 사용할 변수 및 함수 선언을 호이스팅**하며,

선언된 변수와 함수는 해당 **컨텍스트의 최상단**으로 끌어올려진다.

#### - 호이스팅은 선언만 끌어올림:

중요한 점은 호이스팅이 변수와 함수의 **선언**만을 끌어올리며, 초기화나 할당 부분은 호이스팅되지 않는다.

이로 인해 변수는 선언 위치에서 초기화되기 전에 사용될 때 undefined 값으로 초기화된다.

#### - 변수의 스코프와 실행 컨텍스트:

호이스팅으로 인해 변수가 해당 컨텍스트의 최상단으로 이동하므로

해당 컨텍스트 내에서 어디서든 참조할 수 있다.

#### - 호이스팅과 함수 정의:

함수 **선언**은 해당 컨텍스트 내에서 호이스팅되며, 함수 표현식은 호이스팅되지 않는다.

따라서 함수 선언은 선언된 위치와 상관없이 호출할 수 있지만 함수 표현식은 할당된 이후에만 호출할 수 있다.

\*실행 컨텍스트는 코드 실행 중에 현재 상태와 변수의 값 등을 관리

\*호이스팅은 이러한 실행 컨텍스트 내에서 선언과 초기화의 순서를 설명

---

### 스코프의 개념

---

### Lexical Scope란

---

### 스코프 체인이란

---

### 스코프체인을 실행컨텍스트에 연관지어 설명해보기

---

### 이벤트 루프란

---

### 이벤트 루프의 구조

---

### setTimeout(fn, 0) 코드가 실행되는 과정을 이벤트 루프 구조를 통해 설명해주세요

---

### 실행 컨텍스트의 구조는 어떻게 되어있는지

---

### environment record가 무엇인가요

---

### environment record와 호이스팅이랑은 무슨 연관이 있나요

---

### tdz란 무엇인가요
