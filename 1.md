## 데이터 타입

### Map,Set의 개념

#### Map과 Set

:데이터를 저장하고 관리하는데 사용되는 두가지의 자료구조

#### 1. Map

**키-값(key-value)쌍을 저장**하는 자료구조. 키는 **중복되지 않으며** 순서를 보장.

```
// Map 생성
let myMap = new Map();

// 값 추가
myMap.set("key1", "value1")
myMap.set("key2", "value2");
console.log(myMap.get("key1")); // "value1"
```

#### 2. Set

**고유한 값**들을 저장하는 자료구조. (중복된 원소를 포함하지 않는다)

```
// Set 생성
let mySet = new Set();

// 값 추가
mySet.add("value1");
mySet.add("value2");
mySet.add("value1"); // 중복된 값은 무시됨

// 원소 확인
console.log(mySet.has("value1")); // true
console.log(mySet.has("value3")); // false
```

ES6(ECMAScript 2015)부터 이러한 자료 구조가 표준으로 도입
Map과 Set은 유용한 자료 구조로, 데이터를 보다 효율적으로 저장하고 관리하는 데 도움이 된다.

---

### 불변성이 필요한 이유

객체가 불변한다는 것 : 객체가 최초 생성되었을때 **값이 변하지 않고 유지**된다는 의미

불변성을 지키면 원본 데이터가 **변경, 훼손** 되는 것을 막을 수 있다

```
함수형 프로그래밍에서 요구하는 수준의 immutability을 실현하는 방법은 생각보다 까다롭다. Object.freeze, Object.assign, 스프레드 연산자는 2차원 이상의 객체의 깊은 복사를 완벽하게 수행하지 하지 못하기 때문 (JSON 메서드를 사용해야 완벽한 깊은 복사가 가능함)
```

객체를 immutable 하게 생성한다면 생성 시점 이후 해당 객체의 상태를 변경할 수 없으므로, 실행 중인 쓰레드 간 서로의 간섭에 의해 생길 수 있는 동기화(synchronization) 문제에 대한 걱정을 안 해도 되게끔 해준다

(이것을 바로 Thread safe 하다고 함)

#### 배열과 객체로 불변성을 지키면서 값을 업데이트 하는 방법

#### 1. 배열

배열에 값을 추가하거나 수정할때는 spread 연산자('...')를 사용하여 새로운 배열을 생성하고, 값을 추가하거나 수정한다.

```
// 값 추가
const newArray = [...oldArray, newValue]

// 값 수정
const newArray = oldArray.map((i, index)=> index ==== targetIndex ? newValue : i)
```

#### 2. 객체

객체의 속성을 추가, 삭제할때는 spread 연산자('...')를 사용하여 새로운 객체를 생성하고, 속성을 추가하거나 수정한다.

```
// 속성 추가
const newObject = {...oldObject, newProperty : newValue}

// 속성 수정
const newObject = {...oldObject, existingProperty : newValue}

// 속성 삭제
const { propertyToDelete, ...newProperty } = oldObject
```

---

### 얕은 복사와 깊은 복사의 차이

얕은 복사는 객체의 **참조값**(주소 값)을 복사하고

깊은 복사는 객체의 **실제 값**을 복사한다

```
자바스크립트에서 `원시 타입`(primitive type)의 값은 새로운 메모리 공간에 독립적인 값을 저장하기 때문에 깊은 복사가 되고, `참조 타입`(reference type)값은 얕은 복사가 된다.
```

참조 타입은 원본이 바뀌면 참조 타입은 복사본도 같이 변경되지만, 원시 타입은 변경되지 않는다는 점이 큰 차이점이다.

#### 원시 타입의 깊은 복사

```
let a = '원본 데이터';
let b = a;
a = '수정 데이터';

console.log(a); => '수정 데이터' /
console.log(b); => '원본 데이터'
```

원시 타입은 복사 시 값 자체를 담은 독립적인 메모리를 생성하기 때문에

a가 재할당 되더라도 b에는 아무런 영향을 미치지 않는다.

#### 참조 타입의 얕은 복사

```
let a = {name:'원본 데이터'};
let b = a;

a.name = '수정 데이터';

console.log(a); -> '수정 데이터'
console.log(b); -> '수정 데이터'
```

참조 타입인 오브젝트는 **새로운 값으로 변수 값을 재할당** 하자
복사된 변숫값도 **같이 변경**되는 것을 확인할 수 있다.

즉, 데이터가 그대로 하나 더 생성된 것이 아닌

해당 데이터의 메모리 주소를 전달하게 돼서

결국 한 데이터를 공유하게 되는 걸 알 수 있다.

### 정리

#### 얕은 복사(Shallow Copy)

객체를 복사할 때 기존 값과 복사된 값이 같은 참조를 가리키고 있는 것

객체 안에 객체가 있을 경우 한 개의 객체라도 기존 변수의 객체를 참조하고 있다면

이를 `얕은복사`라고 한다

예로 **Array.prototype.slice()가 있다**

```
const original = ['a',2,true,4,"hi"];
const copy = original.slice();`

console.log(original); -> [ 'a', 2, true, 4, 'hi' ]

console.log(copy); -> [ 'a', 2, true, 4, 'hi', 10 ]
```

#### 깊은 복사(Deep Copy)

깊은 복사된 객체는 객체 안에 객체가 있을 경우에도 원본과의 참조가 완전히 끊어진 객체를 말한다.

복사를 하는 목적은 기존 객체의 값만 복사본으로 가져와 별도로 활용하기 위함이 대부분이다.

**원본의 참조는 더 이상 하지 않는다.**

객체의 깊은 복사 예로는 **Object.assign()가 있다**
\*Object.assign(생성할 객체, 복사할 객체);

```
const obj = { a: 1 };
const copyObj = Object.assign({}, obj);

copyObj.a = 2;

console.log(obj); -> { a: 1 } /
console.log(obj === copyObj); -> false
```

위 예제는 copyObj라는 객체를 Object.assign() 메소드를 사용하여 생성한 코드이다.

copyObj.a 값을 변경하여도 기존의 obj.a의 값이 바뀌지 않았다.

서로의 객체를 비교해도 false가 뜨며 서로 참조값이 다른 것을 알 수 있다.

\*cf. Object.assign()은 2차원 객체를 복사하였을 때 **깊은 복사가 이루어지지 않는다** 2단 이상의 객체를 깊은 복사하려면 `JSON.parse`, `JSON.stringify` 또는 `재귀함수`를 사용하여 객체를 복사해야 한다

(Spread 연산자도 Object.assign()과 마찬가지로 2차원 객체는 얕은 복사가 됨.)

---

### 프로퍼티란 무엇인가

속성이란 뜻으로 JS에서 **객체 내부의 속성**을 의미한다.

프로퍼티는 `Key(키) : value(값)`의 형식으로 객체 안에 콤마(쉼표)로 구분되어 할당 된다.

Key는 속성명으로 문자열만 가능하고

Value는 속성값이라고 부르며 어떤 값이던지(문자열, 숫자, 객체, 함수 등) 상관없다.

객체에 함수를 정의할 경우 **메소드**라고 부른다.

#### 객체의 프로퍼티 접근

- 점표기법 접근 (변수명.a)
- 대괄호 표기법 (변수명['a'])

---

### 객체의 참조 과정을 설명

#### 객체 생성

```
var person = { name : 'Jin', age : 25}
```

#### 메모리 할당

객체는 메모리에 할당된다. 이때 메모리에는 **객체의 데이터와 메서드가 저장**됩니다.

person 변수는 이 메모리 위치를 참조하게 됩니다.

#### 참조 및 사용

person 변수는 객체를 참조하고 있으므로 프로퍼티에 접근하거나 수정 할 수 있다.

```
console.log(person.name)
console.log(person.age)

person.age = 31;
// age 프로퍼티 값 변경
```

#### 참조 복사

변수에 객체를 할당할 때 실제로 객체가 복사되는것은 아니다.

객체의 참조(메모리 위치)가 변수에 할당이 되는것이며

객체의 크기나 내용에 상관없이 빠르게 변수에 접근할 수 있도록 도와준다.

```
var anotherPerson = person;
```

이제 anotherPerson과 person 변수는 동일한 객체를 가리킨다.
변경사항은 양쪽 변수에 영향을 미친다.

#### 객체의 가비지 수거

객체를 더이상 참조하지 않는 경우 JS엔진은 **가비지 수거**를 수행 및 해당 객체를 메모리에서 제거한다.

이러한 과정을 통해 JS에서는 객체를 생성 및 참조하며 참조된 객체의 프로퍼티를 사용하고 수정할 수 있다. 중요한 것은 **객체의 참조가 변수에 저장**되며 **여러 변수가 동일한 객체를 참조할 수 있다**는 것.

이를 통해 객체의 데이터를 공유하거나 변경할 수 있다.

---

### call by value vs call by reference

#### 값에 의한 호출(call by Value)

함수에 인자로 변수를 전달할 때 **변수의 값**을 복사하여 전달하는 방식

함수 내부에서 인자의 **값이 변경**되더라도 **호출자에게 영향을 미치지 않는다**.

주로 원시 데이터 타입(예: 숫자, 문자열, 불리언)을 다룰 때 사용

```
function increment(value){  value++;
}

var num = 5;
increment(num);
console.log(num);

출력 : 5
```

#### 참조에 의한 호출(call by Reference)

함수에 인자로 변수를 전달할 때 **변수의 참조**(메모리 위치)를 전달하는 방식

함수 내부에서 인자의 **값이 변경**되면 **호출자에게도 영향**을 미친다.

**배열**이나 **객체**와 같은 복합 데이터 타입을 다룰때 사용

```
function modifyArray(arr) {
    arr.push(4);
}

var myArray = [1,2,3];

modifyArray(myArray);

console.log(myArray);

출력 : [1,2,3,4]
```

#### 요약

자바스크립트에서 함수 호출은 "값에 의한 호출"로 동작한다.

함수에 인자로 **변수**를 전달할 때 해당 **변수의 값이 복사**되어 **함수 내부로 전달**되므로 함수 내에서 변수의 값을 변경해도 **원본 변수에는 영향을 미치지 않는다**

그러나 객체와 같은 참조 데이터 타입을 다룰 때 **객체의 참조가 함수로 전달**되므로 함수 내에서 객체를 수정하면 **호출자에게 영향이 미친다**

---

### 변수를 할당하는 과정

1. 변수 선언

- 변수에 사용할 이름(식별자) 지정

2. 변수 초기화

- 값을 할당하거나 초기화한다(변수 데이터 유형이 결정)

3. 변수 할당

- 변수에 값을 할당하면 변수가 해당 값을 가지게 된다.

4. 변수 사용

- 변수를 사용하여 값을 읽거나, 수정할 수 있다
- 다른 변수에 할당하거나 연산에 활용할 수 있다

5. 변수 변경

- 새로운 값을 할당하여 변수의 내용을 변경할 수 있다

#### 요약

변수는 프로그래밍에서 데이터를 저장하고 관리하는 핵심 요소 중 하나이며,

필요한 값을 저장하고 나중에 사용할 수 있도록 도와주며, 값의 변경이나 연산 등을 통해 프로그램의 동작을 제어하는 데 사용된다

---

### 객체를 할당하는 과정

1. 객체 생성

- 객체에 사용할 이름(식별자) 정의
- {} 중괄호를 사용하여 생성하고, **프로퍼티(속성)와 값**을 가질 수 있다

2. 객체 할당

- 객체를 변수에 할당하여 변수가 해당 객체를 참조하게 된다

3. 객체 사용

- 변수를 사용하여 객체의 프로퍼티에 접근하거나 수정할 수 있다

4. 객체 변경

- 객체 내 프로퍼티를 변경하거나 새로운 프로퍼티 추가할 수 있다
- 동적으로 프로퍼티 관리가 가능함

5. 객체 참조

- **여러 변수가 동일한 객체를 참조**할 수 있다
- 이 변수들은 모두 **같은 객체**를 가르키므로 하나의 변수를 통해 객체를 수정하면 **다른 변수를 통해서도 수정이 반영**된다

#### 요약

객체는 복잡한 데이터를 저장하고 관리하는 데 사용되며, 프로퍼티와 메서드로 구성된다.

객체를 변수에 할당하여 변수가 해당 객체를 참조하게 되면, 변수를 통해 객체를 조작하고 데이터를 읽고 쓸 수 있다.

---

### undefined와 null의 사용법에 따른 차이

#### undefined

변수가 선언되었지만 값을 할당하지 않은 상태를 의미

함수 내에서 **매개변수가 인자로 전달되지 않았을 때** 해당 매개변수 값은 **undefined**가 된다

변수가 선언되지 않았거나 객체 프로퍼티가 존재하지 않는 경우에 변수 또는 프로퍼티 값은 **undefined**가 된다

undefined는주로 변수 초기화 전 또는 값이 아직 할당되지 않은 상태를 나타낼 때 사용

```
var name; console.log(name); // 출력: undefined

function greet(person) {
    console.log("Hello, " + person);
}

greet(); // 매개변수 person에 인자 전달하지 않음

출력: "Hello, undefined"
```

#### null

의도적으로 변수에 `비어있음` 또는 `값이 없음`을 나타내기 위해 사용

개발자가 변수에 명시적으로 값이 없음을 설정하거나,
객체에서 프로퍼티를 제거하고 빈 상태로 만들 때 사용

\*null은 undefined와 다르게 명시적으로 할당한다

#### 요약

**undefined**는 변수의 초기화를 나타내거나 `값이 할당되지 않은 상태`를 나타내고,

**null**은 명시적으로 `값이 없음`을 나타내거나 변수나 객체 프로퍼티를 초기화하기 위해 사용.

---

### 상수와 불변값의 차이

#### 상수

프로그래밍에서 **값을 변경할 수 없는 변수**를 의미, 값이 한 번 설정되면 그 값을 변경할 수 없다

\*Javascript에서는 const 키워드 사용

#### 불변값

값을 변경할 수 없는 **데이터**를 가르킨다
변수의 특성이 아닌 데이터의 특성이다,

즉. 데이터 자체가 변경 불가능한것이다.

대부분 원시 데이터 유형(숫자, 불리언, 문자열)은 불변값이다. 이러한 값은 변경할 수 없으며 값을 수정하려면 새로운 값을 생성해야한다.

#### 요약

상수는 변수의 값을 변경할 수 없는것을 보장하고, 불변값은 값 자체를 변경할 수 없는것을 나타낸다

불변값은 예를들어 함수형 프로그래밍에서 많이 사용되며, 상수는 변수의 불변성을 보장하기 위해 사용된다.
